# Спецификация алгоритма сопоставления вин по тексту с этикетки

Этот документ описывает многоступенчатый алгоритм для идентификации вина из базы данных на основе текста, распознанного с винной этикетки.

## 1. Извлечение и очистка ключевых сущностей

Первый и самый важный шаг — это преобразование сырой строки текста от OCR-сервиса в структурированный набор данных. Этот процесс должен быть устойчив к ошибкам распознавания и "мусорным" словам.

### 1.1. Предварительная обработка текста

Перед извлечением сущностей необходимо "очистить" исходный текст:
1.  **Приведение к нижнему регистру**: Весь текст переводится в нижний регистр для унификации поиска.
2.  **Удаление лишних символов**: Удаляются знаки препинания, которые не несут смысловой нагрузки (например, `*`, `_`, `«`, `»`), за исключением тех, что могут быть частью названия или важны для определения контекста (например, `%` для алкоголя, `-` в названиях).
3.  **Нормализация**: Замена распространенных сокращений и синонимов (например, "вино" -> "", "красн." -> "красное", "сух." -> "сухое").
4.  **Удаление стоп-слов**: Исключение общих слов, не несущих уникальной информации о вине (например, "алкоголь", "емкость", "мл", "l", "содержит", "продукт", "качество"). Также сюда относятся специфичные для OCR артефакты, если они известны (например, "итого мужескаго пола на лицо").

### 1.2. Извлечение сущностей

После очистки текста происходит извлечение конкретных атрибутов вина.

#### Название вина (Name) и Производитель (Winery)

Это самые сложные для извлечения, но и самые важные сущности.
- **Подход**: Вместо простого поиска по ключевым словам ("вино", "название"), следует использовать более комплексный подход.
    1.  **Поиск по базе данных**: Сначала нужно получить из базы данных список всех известных названий вин и производителей.
    2.  **Поиск совпадений**: Проверить наличие этих названий и производителей в "очищенном" тексте с этикетки. Это позволяет избежать жесткой привязки к словам-маркерам.
    3.  **Использование N-грамм**: Разбить текст этикетки на N-граммы (последовательности из 1, 2, 3 слов) и искать совпадения с базой названий/производителей. Это поможет найти совпадения, даже если в названии несколько слов.
    4.  **Обработка кавычек**: Текст в кавычках (`"..."` или `'...'`) с высокой вероятностью является названием вина.

#### Год урожая (Vintage)

- **Подход**: Поиск 4-значного числа в диапазоне, соответствующем реальным годам производства вина (например, с 1900 до текущего года + 1).
- **Контекст**: Приоритет отдается числам, стоящим рядом со словами "год", "урожай", "vintage", "harvest". Если таких слов нет, любое 4-значное число в тексте является кандидатом.

#### Сорт винограда (Grape Variety)

- **Подход**:
    1.  **Справочник сортов**: Создать и поддерживать в базе данных справочник всех возможных сортов винограда (например, "Saperavi", "Chardonnay", "Саперави", "Шардоне").
    2.  **Поиск по справочнику**: Искать точные и частичные совпадения слов из справочника в тексте этикетки.

#### Цвет (Color) и Сахар (Sugar)

- **Подход**: Поиск по ключевым словам-маркерам и их вариациям.
    - **Цвет**: "красное", "белое", "розовое", "red", "white", "rose".
    - **Сахар**: "сухое", "полусухое", "полусладкое", "сладкое", "брют", "dry", "semi-dry", "semi-sweet", "sweet", "brut".

#### Крепость (Alcohol Level)

- **Подход**: Поиск числа (целого или десятичного) рядом со знаком процента `%` или словами "крепость", "алк.", "alc.".

## 2. Приоритизация сущностей для поиска

Не все извлеченные сущности одинаково важны для точной идентификации вина. Алгоритм должен учитывать их значимость при построении запросов и ранжировании результатов.

Приоритеты (от высшего к низшему):

1.  **Название (Name) и Производитель (Winery)**:
    *   **Приоритет: Высочайший**. Это самые уникальные идентификаторы вина. Совпадение по этим полям дает наибольшую уверенность в результате. Часто название и производитель могут быть перепутаны или совпадать, поэтому их следует рассматривать в связке.

2.  **Сорт винограда (Grape Variety)**:
    *   **Приоритет: Высокий**. Уникальный сорт или бленд является сильным сигналом. Менее надежен, чем название, так как один и тот же сорт используется многими производителями.

3.  **Год урожая (Vintage)**:
    *   **Приоритет: Средний**. Полезен для фильтрации, когда найдено несколько вин с одинаковым названием, но разных лет. Сам по себе (без названия) почти бесполезен.

4.  **Цвет (Color) и Сахар (Sugar)**:
    *   **Приоритет: Низкий**. Это общие характеристики. Они используются в основном для **фильтрации и исключения** нерелевантных результатов, а не для основного поиска. Например, если на этикетке четко указано "красное", все белые вина можно сразу отбросить.

5.  **Крепость (Alcohol Level)**:
    *   **Приоритет: Очень низкий**. Используется как дополнительный уточняющий фактор при прочих равных, так как может незначительно варьироваться от партии к партии.

## 3. Многоступенчатая стратегия поиска

Поиск должен выполняться в несколько последовательных этапов. Если на одном из этапов найдено достаточно релевантное совпадение (или несколько), процесс может быть остановлен.

### Шаг 1: Поиск по точному совпадению (Highest-Priority Search)

**Цель**: Найти идеальное совпадение.
**Логика**:
1.  Выполнить поиск в базе данных, где `название` И `производитель` извлеченные из текста, полностью соответствуют полям в базе.
    - `(db.name ILIKE extracted.name AND db.winery ILIKE extracted.winery)`
2.  Если производитель не извлечен, но извлечено название, ищется точное совпадение по названию.
    - `(db.name ILIKE extracted.name)`
3.  **Условие перехода к следующему шагу**: Если на этом шаге не найдено ни одного результата.

### Шаг 2: Полнотекстовый поиск по ключевым сущностям (Full-Text Search)

**Цель**: Найти вина, которые содержат наиболее важные слова из текста этикетки.
**Логика**:
1.  Сформировать поисковый запрос из самых приоритетных извлеченных сущностей: **Название** и **Производитель**. Если они не найдены, использовать **Сорт винограда**.
2.  Использовать полнотекстовый поиск (например, `tsvector` в PostgreSQL) для поиска вин, содержащих *все* или *любое* из этих ключевых слов.
    - Пример запроса: `to_tsvector('russian', db.name || ' ' || db.winery) @@ to_tsquery('russian', 'villa & krim & saperavi')`
3.  На этом этапе можно получить довольно много результатов, которые будут отфильтрованы и ранжированы на следующих шагах.
4.  **Условие перехода к следующему шагу**: Если найдено 0 результатов или найдено слишком много (> 20) общих результатов.

### Шаг 3: Расширенный поиск с фильтрацией (Filtered Search)

**Цель**: Сузить результаты, полученные на предыдущем шаге, или выполнить новый, более широкий поиск с использованием второстепенных атрибутов.
**Логика**:
1.  **Если на Шаге 2 есть результаты**:
    - Применить к ним фильтры по **сорту винограда**, **году**, **цвету** и **сахару**, если эти данные были извлечены.
    - Например, если найдено 10 вин "Villa Krim", но извлечен год "2022", отфильтровать список, оставив только вина этого года.
2.  **Если на Шаге 2 нет результатов**:
    - Выполнить новый, более гибкий поиск. Например, искать по частичному совпадению ( `ILIKE '%word%'` ) названия или производителя.
    - `(db.name ILIKE '%villa%' OR db.name ILIKE '%krim%')`
    - Сразу же применить к этому поиску жесткие фильтры по **сорту**, **цвету**, **сахару**, чтобы ограничить количество нерелевантных результатов.

### Шаг 4: Поиск по самому длинному общему подслову (Longest Common Substring)

**Цель**: "Поймать" вина, которые не нашлись предыдущими способами из-за ошибок OCR или нестандартного написания.
**Логика**:
1.  Этот шаг выполняется, если предыдущие не дали уверенного результата.
2.  Из "очищенной" строки текста этикетки берутся самые длинные слова (например, > 4 символов).
3.  Выполняется поиск `ILIKE` по этим словам в полях `name` и `winery`.
    - `(db.name ILIKE '%saperavi%' OR db.winery ILIKE '%inkerman%')`
4.  Результаты этого шага будут иметь самый низкий "врожденный" ранг и потребуют тщательной оценки релевантности.

## 4. Ранжирование результатов и выбор лучшего совпадения

После того как один или несколько поисковых шагов вернули список вин-кандидатов, необходимо оценить релевантность каждого из них, чтобы предложить пользователю наиболее подходящий вариант.

### 4.1. Система начисления очков (Scoring System)

Каждому вину-кандидату присваиваются очки на основе того, какие из его атрибутов совпали с извлеченными из текста сущностями.

| Совпавший атрибут | Тип совпадения | Очки | Примечание |
| :--- | :--- | :--- | :--- |
| **Название/Производитель** | Точное | +50 | Самый сильный сигнал. |
| | Частичное (все слова) | +30 | Например, `Villa Krim` найдено в `Wine Villa Krim Select`. |
| | Частичное (одно из слов) | +15 | Например, только `Krim` найдено. |
| **Сорт винограда** | Точное | +20 | |
| **Год урожая** | Точное | +10 | |
| **Цвет** | Точное | +5 | Используется и для фильтрации, и для очков. |
| **Сахар** | Точное | +5 | |
| **Несовпадение атрибута** | - | -10 | Штраф, если извлеченный атрибут (например, цвет "красное") не совпадает с атрибутом вина в базе (например, "белое"). |

### 4.2. Процесс выбора

1.  **Применение очков**: Для каждого вина-кандидата из результатов поиска подсчитывается итоговая сумма очков.
2.  **Сортировка**: Список кандидатов сортируется по убыванию очков.
3.  **Выбор лучшего результата**:
    *   **Сценарий 1: Явный лидер**. Если у первого вина в списке значительно больше очков, чем у второго (например, разница > 20 очков), оно считается лучшим совпадением.
    *   **Сценарий 2: Несколько сильных кандидатов**. Если у нескольких вин близкое количество очков, можно вернуть топ-3 варианта, чтобы пользователь сам сделал окончательный выбор.
    *   **Сценарий 3: Нет уверенных кандидатов**. Если ни одно вино не набрало достаточно очков (например, > 30), считается, что совпадений не найдено.

Этот алгоритм обеспечивает гибкий, но в то же время точный механизм поиска, который устойчив к ошибкам OCR и предоставляет релевантные результаты.
